{"ast":null,"code":"var _a;\nimport { b64tohex, hex2b64 } from \"./lib/jsbn/base64\";\nimport { JSEncryptRSAKey } from \"./JSEncryptRSAKey\";\nvar version = typeof process !== 'undefined' ? (_a = process.env) === null || _a === void 0 ? void 0 : _a.npm_package_version : undefined;\n/**\r\n *\r\n * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour\r\n * possible parameters are:\r\n * - default_key_size        {number}  default: 1024 the key size in bit\r\n * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent\r\n * - log                     {boolean} default: false whether log warn/error or not\r\n * @constructor\r\n */\nvar JSEncrypt = /** @class */function () {\n  function JSEncrypt(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    options = options || {};\n    this.default_key_size = options.default_key_size ? parseInt(options.default_key_size, 10) : 1024;\n    this.default_public_exponent = options.default_public_exponent || \"010001\"; // 65537 default openssl public exponent for rsa key type\n    this.log = options.log || false;\n    // The private and public key.\n    this.key = null;\n  }\n  /**\r\n   * Method to set the rsa key parameter (one method is enough to set both the public\r\n   * and the private key, since the private key contains the public key paramenters)\r\n   * Log a warning if logs are enabled\r\n   * @param {Object|string} key the pem encoded string or an object (with or without header/footer)\r\n   * @public\r\n   */\n  JSEncrypt.prototype.setKey = function (key) {\n    if (this.log && this.key) {\n      console.warn(\"A key was already set, overriding existing.\");\n    }\n    this.key = new JSEncryptRSAKey(key);\n  };\n  /**\r\n   * Proxy method for setKey, for api compatibility\r\n   * @see setKey\r\n   * @public\r\n   */\n  JSEncrypt.prototype.setPrivateKey = function (privkey) {\n    // Create the key.\n    this.setKey(privkey);\n  };\n  /**\r\n   * Proxy method for setKey, for api compatibility\r\n   * @see setKey\r\n   * @public\r\n   */\n  JSEncrypt.prototype.setPublicKey = function (pubkey) {\n    // Sets the public key.\n    this.setKey(pubkey);\n  };\n  /**\r\n   * Proxy method for RSAKey object's decrypt, decrypt the string using the private\r\n   * components of the rsa key object. Note that if the object was not set will be created\r\n   * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\r\n   * @param {string} str base64 encoded crypted string to decrypt\r\n   * @return {string} the decrypted string\r\n   * @public\r\n   */\n  JSEncrypt.prototype.decrypt = function (str) {\n    // Return the decrypted string.\n    try {\n      return this.getKey().decrypt(b64tohex(str));\n    } catch (ex) {\n      return false;\n    }\n  };\n  /**\r\n   * Proxy method for RSAKey object's encrypt, encrypt the string using the public\r\n   * components of the rsa key object. Note that if the object was not set will be created\r\n   * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\r\n   * @param {string} str the string to encrypt\r\n   * @return {string} the encrypted string encoded in base64\r\n   * @public\r\n   */\n  JSEncrypt.prototype.encrypt = function (str) {\n    // Return the encrypted string.\n    try {\n      return hex2b64(this.getKey().encrypt(str));\n    } catch (ex) {\n      return false;\n    }\n  };\n  /**\r\n   * Proxy method for RSAKey object's sign.\r\n   * @param {string} str the string to sign\r\n   * @param {function} digestMethod hash method\r\n   * @param {string} digestName the name of the hash algorithm\r\n   * @return {string} the signature encoded in base64\r\n   * @public\r\n   */\n  JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {\n    // return the RSA signature of 'str' in 'hex' format.\n    try {\n      return hex2b64(this.getKey().sign(str, digestMethod, digestName));\n    } catch (ex) {\n      return false;\n    }\n  };\n  /**\r\n   * Proxy method for RSAKey object's verify.\r\n   * @param {string} str the string to verify\r\n   * @param {string} signature the signature encoded in base64 to compare the string to\r\n   * @param {function} digestMethod hash method\r\n   * @return {boolean} whether the data and signature match\r\n   * @public\r\n   */\n  JSEncrypt.prototype.verify = function (str, signature, digestMethod) {\n    // Return the decrypted 'digest' of the signature.\n    try {\n      return this.getKey().verify(str, b64tohex(signature), digestMethod);\n    } catch (ex) {\n      return false;\n    }\n  };\n  /**\r\n   * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object\r\n   * will be created and returned\r\n   * @param {callback} [cb] the callback to be called if we want the key to be generated\r\n   * in an async fashion\r\n   * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object\r\n   * @public\r\n   */\n  JSEncrypt.prototype.getKey = function (cb) {\n    // Only create new if it does not exist.\n    if (!this.key) {\n      // Get a new private key.\n      this.key = new JSEncryptRSAKey();\n      if (cb && {}.toString.call(cb) === \"[object Function]\") {\n        this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);\n        return;\n      }\n      // Generate the key.\n      this.key.generate(this.default_key_size, this.default_public_exponent);\n    }\n    return this.key;\n  };\n  /**\r\n   * Returns the pem encoded representation of the private key\r\n   * If the key doesn't exists a new key will be created\r\n   * @returns {string} pem encoded representation of the private key WITH header and footer\r\n   * @public\r\n   */\n  JSEncrypt.prototype.getPrivateKey = function () {\n    // Return the private representation of this key.\n    return this.getKey().getPrivateKey();\n  };\n  /**\r\n   * Returns the pem encoded representation of the private key\r\n   * If the key doesn't exists a new key will be created\r\n   * @returns {string} pem encoded representation of the private key WITHOUT header and footer\r\n   * @public\r\n   */\n  JSEncrypt.prototype.getPrivateKeyB64 = function () {\n    // Return the private representation of this key.\n    return this.getKey().getPrivateBaseKeyB64();\n  };\n  /**\r\n   * Returns the pem encoded representation of the public key\r\n   * If the key doesn't exists a new key will be created\r\n   * @returns {string} pem encoded representation of the public key WITH header and footer\r\n   * @public\r\n   */\n  JSEncrypt.prototype.getPublicKey = function () {\n    // Return the private representation of this key.\n    return this.getKey().getPublicKey();\n  };\n  /**\r\n   * Returns the pem encoded representation of the public key\r\n   * If the key doesn't exists a new key will be created\r\n   * @returns {string} pem encoded representation of the public key WITHOUT header and footer\r\n   * @public\r\n   */\n  JSEncrypt.prototype.getPublicKeyB64 = function () {\n    // Return the private representation of this key.\n    return this.getKey().getPublicBaseKeyB64();\n  };\n  JSEncrypt.version = version;\n  return JSEncrypt;\n}();\nexport { JSEncrypt };","map":{"version":3,"names":["_a","b64tohex","hex2b64","JSEncryptRSAKey","version","process","env","npm_package_version","undefined","JSEncrypt","options","default_key_size","parseInt","default_public_exponent","log","key","prototype","setKey","console","warn","setPrivateKey","privkey","setPublicKey","pubkey","decrypt","str","getKey","ex","encrypt","sign","digestMethod","digestName","verify","signature","cb","toString","call","generateAsync","generate","getPrivateKey","getPrivateKeyB64","getPrivateBaseKeyB64","getPublicKey","getPublicKeyB64","getPublicBaseKeyB64"],"sources":["C:/Users/User/Downloads/loginwithadmin/AivleBigProject/frontend/node_modules/jsencrypt/lib/JSEncrypt.js"],"sourcesContent":["var _a;\r\nimport { b64tohex, hex2b64 } from \"./lib/jsbn/base64\";\r\nimport { JSEncryptRSAKey } from \"./JSEncryptRSAKey\";\r\nvar version = typeof process !== 'undefined'\r\n    ? (_a = process.env) === null || _a === void 0 ? void 0 : _a.npm_package_version\r\n    : undefined;\r\n/**\r\n *\r\n * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour\r\n * possible parameters are:\r\n * - default_key_size        {number}  default: 1024 the key size in bit\r\n * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent\r\n * - log                     {boolean} default: false whether log warn/error or not\r\n * @constructor\r\n */\r\nvar JSEncrypt = /** @class */ (function () {\r\n    function JSEncrypt(options) {\r\n        if (options === void 0) { options = {}; }\r\n        options = options || {};\r\n        this.default_key_size = options.default_key_size\r\n            ? parseInt(options.default_key_size, 10)\r\n            : 1024;\r\n        this.default_public_exponent = options.default_public_exponent || \"010001\"; // 65537 default openssl public exponent for rsa key type\r\n        this.log = options.log || false;\r\n        // The private and public key.\r\n        this.key = null;\r\n    }\r\n    /**\r\n     * Method to set the rsa key parameter (one method is enough to set both the public\r\n     * and the private key, since the private key contains the public key paramenters)\r\n     * Log a warning if logs are enabled\r\n     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.setKey = function (key) {\r\n        if (this.log && this.key) {\r\n            console.warn(\"A key was already set, overriding existing.\");\r\n        }\r\n        this.key = new JSEncryptRSAKey(key);\r\n    };\r\n    /**\r\n     * Proxy method for setKey, for api compatibility\r\n     * @see setKey\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.setPrivateKey = function (privkey) {\r\n        // Create the key.\r\n        this.setKey(privkey);\r\n    };\r\n    /**\r\n     * Proxy method for setKey, for api compatibility\r\n     * @see setKey\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.setPublicKey = function (pubkey) {\r\n        // Sets the public key.\r\n        this.setKey(pubkey);\r\n    };\r\n    /**\r\n     * Proxy method for RSAKey object's decrypt, decrypt the string using the private\r\n     * components of the rsa key object. Note that if the object was not set will be created\r\n     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\r\n     * @param {string} str base64 encoded crypted string to decrypt\r\n     * @return {string} the decrypted string\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.decrypt = function (str) {\r\n        // Return the decrypted string.\r\n        try {\r\n            return this.getKey().decrypt(b64tohex(str));\r\n        }\r\n        catch (ex) {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Proxy method for RSAKey object's encrypt, encrypt the string using the public\r\n     * components of the rsa key object. Note that if the object was not set will be created\r\n     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor\r\n     * @param {string} str the string to encrypt\r\n     * @return {string} the encrypted string encoded in base64\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.encrypt = function (str) {\r\n        // Return the encrypted string.\r\n        try {\r\n            return hex2b64(this.getKey().encrypt(str));\r\n        }\r\n        catch (ex) {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Proxy method for RSAKey object's sign.\r\n     * @param {string} str the string to sign\r\n     * @param {function} digestMethod hash method\r\n     * @param {string} digestName the name of the hash algorithm\r\n     * @return {string} the signature encoded in base64\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {\r\n        // return the RSA signature of 'str' in 'hex' format.\r\n        try {\r\n            return hex2b64(this.getKey().sign(str, digestMethod, digestName));\r\n        }\r\n        catch (ex) {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Proxy method for RSAKey object's verify.\r\n     * @param {string} str the string to verify\r\n     * @param {string} signature the signature encoded in base64 to compare the string to\r\n     * @param {function} digestMethod hash method\r\n     * @return {boolean} whether the data and signature match\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {\r\n        // Return the decrypted 'digest' of the signature.\r\n        try {\r\n            return this.getKey().verify(str, b64tohex(signature), digestMethod);\r\n        }\r\n        catch (ex) {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object\r\n     * will be created and returned\r\n     * @param {callback} [cb] the callback to be called if we want the key to be generated\r\n     * in an async fashion\r\n     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.getKey = function (cb) {\r\n        // Only create new if it does not exist.\r\n        if (!this.key) {\r\n            // Get a new private key.\r\n            this.key = new JSEncryptRSAKey();\r\n            if (cb && {}.toString.call(cb) === \"[object Function]\") {\r\n                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);\r\n                return;\r\n            }\r\n            // Generate the key.\r\n            this.key.generate(this.default_key_size, this.default_public_exponent);\r\n        }\r\n        return this.key;\r\n    };\r\n    /**\r\n     * Returns the pem encoded representation of the private key\r\n     * If the key doesn't exists a new key will be created\r\n     * @returns {string} pem encoded representation of the private key WITH header and footer\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.getPrivateKey = function () {\r\n        // Return the private representation of this key.\r\n        return this.getKey().getPrivateKey();\r\n    };\r\n    /**\r\n     * Returns the pem encoded representation of the private key\r\n     * If the key doesn't exists a new key will be created\r\n     * @returns {string} pem encoded representation of the private key WITHOUT header and footer\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.getPrivateKeyB64 = function () {\r\n        // Return the private representation of this key.\r\n        return this.getKey().getPrivateBaseKeyB64();\r\n    };\r\n    /**\r\n     * Returns the pem encoded representation of the public key\r\n     * If the key doesn't exists a new key will be created\r\n     * @returns {string} pem encoded representation of the public key WITH header and footer\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.getPublicKey = function () {\r\n        // Return the private representation of this key.\r\n        return this.getKey().getPublicKey();\r\n    };\r\n    /**\r\n     * Returns the pem encoded representation of the public key\r\n     * If the key doesn't exists a new key will be created\r\n     * @returns {string} pem encoded representation of the public key WITHOUT header and footer\r\n     * @public\r\n     */\r\n    JSEncrypt.prototype.getPublicKeyB64 = function () {\r\n        // Return the private representation of this key.\r\n        return this.getKey().getPublicBaseKeyB64();\r\n    };\r\n    JSEncrypt.version = version;\r\n    return JSEncrypt;\r\n}());\r\nexport { JSEncrypt };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}